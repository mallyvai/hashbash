asdfjas
"""
Run with form
simulate.py codefile configfile

configfile has the form:
	max_allowed_cycles: 
	
machine code files have one instruction per line. "comment" lines
are of the form
# mycomment
these are intended to be used for comments, but also for possible
chromosomal division of sorts.

The simulator reads in files and returns the 'hashes' generated by them.

"""
import sys
import bit_params as c

dbg_brk = lambda : None

if c.ENABLE_DEBUG:
	try:
		import IPython
		dbg_brk = IPython.Debugger.Tracer()
	except ValueError: 
		None


def restricted_left_shift(num, shift_amount, num_bits):
	word_mask = (2**num_bits) - 1
	return (num << shift_amount) & word_mask;
def restricted_circ_left_shift(num, shift_amount, num_bits):
	shift_amount %= num_bits
	return restricted_left_shift(num, shift_amount, num_bits) | (num >> (num_bits - shift_amount))
def restricted_circ_right_shift(num, shift_amount, num_bits):
	return restricted_circ_left_shift(num, num_bits-shift_amount, num_bits)

get_field = lambda instr, mask, shift: (instr & mask) >> shift 

def get_msd(field, mask):
	if field & mask == 0:
		return 0
	return 1

class Halted(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)

class BadOpcode(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)

"""
Converts an ASCII string to a big integer
"""
def string_to_integer(string):
	i = 0
	ret_int = 0
	while i < len(string):
		ret_int <<= 8
		ret_int += ord(string[i])
		i += 1
		
	return ret_int

def reverse_bits(num):
	ret_int = 0
	
	while num > 0:
		ret_int <<= 1
		ret_int += (num & 1)
		num >>= 1
	return ret_int

def test_reverse_bits():
	print "13 should be 11", 13, reverse_bits(13)
	print "0 should be 0:", 0, reverse_bits(0)	
	print "7 should be 7:", 7, reverse_bits(7)

class st_input:
	"""
	input_string gets converted into an integer
	size is the net size of input in *bits*; implicitly these means that any
	function that uses this thing can only handle about 2^68 in its input size
	"""
	def __init__(self, input_string):
		self.input_string = input_string
		self.input_bits = reverse_bits(string_to_integer(input_string))
		self.bitsize = len(input_string) * 8
		self.cursor = 0
		
	
	def next(self, num_bits):
		mask = 2**num_bits - 1
		mask <<= self.cursor
		self.cursor += num_bits
		self.cursor %= self.bitsize
		return reverse_bits(mask & self.input_bits)
	
	def prev(self, num_bits):
		mask = 2**num_bits - 1
		self.cursor -= num_bits
		self.cursor %= self.bitsize
		mask <<= self.cursor
		return reverse_bits(mask & self.input_bits)

class Program:
	"""
	A class for representing and simulating a program.
	Has no notion of "maximum cycles"; just blindly steps through
	one cycle at a time.
	"""

	#If we're at the end and we go "forward" again, just repeat the block.
	#Same with if we're at the beginning and go "backward" again.

	def _iter_input(self, forward):
		bits = None
		if forward:
			bits = reverse_bits(self.st_in.next(c.BLOCK_SIZE * c.NUM_INPUT_BLOCKS))
		else:
			bits = reverse_bits(self.st_in.prev(c.BLOCK_SIZE * c.NUM_INPUT_BLOCKS))
		
		i = c.WI_INPUT_START
		while i <= c.WI_INPUT_END:
			self.memory[i] = reverse_bits(bits & c.BLOCK_MASK)
			bits >>= c.BLOCK_SIZE
			i += 1
			
		self.memory[c.WI_TOTAL_INPUT_SIZE] = self.st_in.bitsize
		self.memory[c.WI_BLOCK_SIZE] = c.BLOCK_SIZE #Index of the word the block size for the input is going to be dumped into every time iterinput is called
		self.memory[c.WI_NUM_INPUT_BLOCKS] = c.NUM_INPUT_BLOCKS #Index for number of blocks a call to iterinput will create
		
	def __init__(self, memory, inputstring):
		self.memory = memory
				
		self.st_in = st_input(inputstring)
		self.is_halted = False
	
		self.memory[c.WI_PROGRAM_COUNTER] = c.WI_PROGRAM_START
	
	def get_output(self):
		
		i = 0
		ret_num = 0
		while i < (c.WI_OUTPUT_END - c.WI_OUTPUT_START + 1):
			ret_num <<= c.BLOCK_SIZE
			ret_num += self.memory[i + c.WI_OUTPUT_START]
			i += 1
		return ret_num	
	
	def next_step(self):
		if self.is_halted:
			raise Halted("Program halted")
		
			
		m = self.memory
		
		pc = m[c.WI_PROGRAM_COUNTER]
		pc = abs(pc)
		
		if pc > c.NUM_WORDS: instr = c.ops["halt"]

		
		m[c.WI_PROGRAM_COUNTER] += 1 #pc++
		instr = m[pc]
		
			
		def get_xor(field):
			ret = 1 & field
			while field != 0:
				field >>= 1
				ret ^= (1 & field)
			return ret
		
		f_op = get_field(instr, c.M_OPCODE, c.S_OPCODE)
		f_x = get_field(instr, c.M_X, c.S_X)
		f_y = get_field(instr, c.M_Y, c.S_Y)
		f_z = get_field(instr, c.M_Z, c.S_Z)
		f_dest = get_field(instr, c.M_DEST, c.S_DEST)

		msd_x = get_msd(f_x, c.B_X)
		msd_y = get_msd(f_y, c.B_Y)
		msd_z = get_msd(f_z, c.B_Z)
		msd_dest = get_msd(f_dest, c.B_DEST)
		
		xor_x = get_xor(f_x)
		xor_y = get_xor(f_y)
		xor_z = get_xor(f_z)
		xor_dest = get_xor(f_dest)
		
		x = None
		y = None
		z = None
		dest = None
		
		if msd_x == c.IMM:
			x = f_x & c.M_FVAL
			if c.ENABLE_DEBUG: print "x is imm"
		else: 
			x = m[f_x]
			if c.ENABLE_DEBUG: print "pulling x from mem", f_x
		
		if msd_y == c.IMM:
			y = f_y & c.M_FVAL
			if c.ENABLE_DEBUG: print "y is imm"
		else: 
			y = m[f_y]
			if c.ENABLE_DEBUG: print "pulling y from mem", f_y
		
		if msd_z == c.IMM:
			z = f_z & c.M_FVAL
			if c.ENABLE_DEBUG: print "y is imm"
		
		else:
			z = m[f_z]
			if c.ENABLE_DEBUG: print "pulling z from mem", f_z
		
		if msd_dest == c.IMM:
			dest = f_dest & c.M_FVAL
			if c.ENABLE_DEBUG: print "dest is imm"
		else: 
			dest = m[f_dest] & c.M_FVAL
			if c.ENABLE_DEBUG: print "pulling dest from mem"
		
		dbg_brk()
		if c.ENABLE_DEBUG: print c.r_ops[f_op]
		
		"""Now lets go and actually do the calculations..."""
		if f_op == c.ops["and"]: m[dest] = x & y
		elif f_op == c.ops["nand"]: m[dest] = ~(x & y)
		elif f_op == c.ops["xor"]: m[dest] = x ^ y
		elif f_op == c.ops["or"]: m[dest] = x | y
		elif f_op == c.ops["not"]: m[dest] = ~x
		
		elif f_op == c.ops["mod"]: 
			if y > 0:
				m[dest] = x % y
			else:
				m[dest] = x
				
		elif f_op == c.ops["add"]: 
			if xor_z == 1: y *= -1 #sub if the relevant bit is 1
			if c.ENABLE_DEBUG: print "X+Y=", x+y
			if c.ENABLE_DEBUG: print "X", x,"","Y", y
			m[dest] = (x + y) % 0x100000000000000000 #Because we have 68-bit words, 2^68 is the modulus
		elif f_op == c.ops["shift"]:
			y = abs(y)
			
			if xor_z == 1:
				m[dest] = restricted_left_shift(x, y, c.WORD_SIZE)	 #shift left
			else:  #shift right
				m[dest] = x >> y
		elif f_op == c.ops["cshift"]:
			y = abs(y)
			if xor_z == 1:
				m[dest] = restricted_circ_left_shift(x, y, c.WORD_SIZE)
			else:
				m[dest] = restricted_circ_right_shift(x, y, c.WORD_SIZE)
				
		elif f_op == c.ops["addifeq"]:
			if x == y:
				m[dest] = (m[dest] + z) % c.MAX_WORD_SIZE + 1
		elif f_op == c.ops["addifneq"]:
			if x != y:
				m[dest] = (m[dest] + z) % c.MAX_WORD_SIZE + 1
		elif f_op == c.ops["addiflt"]:
			if x < y:
				m[dest] = (m[dest] + z) % c.MAX_WORD_SIZE + 1
		
		elif f_op == c.ops["setifeq"]:
			if x == y:
				m[dest] = z
		elif f_op == c.ops["setiflt"]:
			if c.ENABLE_DEBUG: print "SETIFLTING"
			if x < y:
				m[dest] = z
		
		elif f_op == c.ops["iterinput"]:
			self._iter_input(xor_x == 1)
		
		elif f_op == c.ops["halt"]:
			if c.ENABLE_DEBUG: print "GOING DOWN FOR HALT!"
			self.is_halted = True
		else:
			raise BadOpcode(f_op)

def prettify_instr(instr):
	f_op = get_field(instr, c.M_OPCODE, c.S_OPCODE)
	f_x = get_field(instr, c.M_X, c.S_X)
	f_y = get_field(instr, c.M_Y, c.S_Y)
	f_z = get_field(instr, c.M_Z, c.S_Z)
	f_dest = get_field(instr, c.M_DEST, c.S_DEST)
	
	d = c.Denary2Binary
	
	return (d(f_dest), d(f_z), d(f_y), d(f_x), d(f_op), str(instr))


class MemTrack:
	def __init__(self, mem):
		self.states = []
		self.states.append(mem[:])
	def next_state(self, mem):
		self.states.append(mem[:])
	def output(self):
		for i, v in enumerate(self.states):
			print "-----State " + str(i) + "-----"
			for j, w in enumerate(v):
				if w != 0:
					print j, ' '.join(prettify_instr(w))

"""
Opportunity for mad-scientist experiment: let full state of program be
transferred on reset - self-extending polymorphic code? Not impossible.
Merely very unlikely.
"""
def initialize_memory(filename):
	memory = [0 for i in xrange(0, c.WI_PROGRAM_START)]

	
	fh = open(filename, 'r')
	#if c.ENABLE_DEBUG: fh = open("/tmp/prog", 'r')
	lines = fh.readlines()
	fh.close()
	
	
	memory.extend([int(line) for line in lines if line[0] != '#' and not line.isspace()])
	while len(memory) < c.NUM_LINES:
		memory.append(0)

	if c.ENABLE_DEBUG: input_string =  """memory.extend([int(line) for line in lines if line[0] != '#' and len(line.strip()) > 0]) ValueError: invalid literal for int() with base 10:"""
	if c.ENABLE_DEBUG: print "beginning simulation"
	
	return memory

def simulate(memory, input_string):
	p = Program(memory, input_string)
	if c.ENABLE_DEBUG: tracker = MemTrack([0])
	
	i = 0
	while i < c.MAX_CYCLES and not p.is_halted:
		#if i % 500 == 0:
		#	print "Cycle", i
		if c.ENABLE_DEBUG: tracker.next_state(p.memory)
		p.next_step()
		
		if c.ENABLE_DEBUG: print "Cycle", i
		i += 1
		
	out = p.get_output()
	if c.ENABLE_DEBUG: tracker.output()
	return out

def main(filename, input_string):
	memory = initialize_memory(filename)
	output = simulate(memory, input_string)
	return output

if __name__ == "__main__":
	input_string = raw_input("String you want to hash:\n")
	output = main(sys.argv[1], input_string)
	print output147576204423850360847
149508909917307672945
147580740252923330604
147640554476178247794
149511579463120853713
149507041091121581063
149510172019516768469
149512151140417408691
149505254865639572567
149505543006490987336
147601572597095470242
147632976091852839634
147589992403056984677
147586876593395470980
149507938773570683064
149514320476624652423
351017549111297603679
149506740168661404984
147580742417578459358
147580742520660295774
149509863674852940513
149506979037418881139
149516435524937062593
147580728879848882522
149513591912599653975
147621168024473043169
149508228632453060276
149516495104286132071
149514614183881610418
149507908605763912181
147580743242212704380
149506765938602546648
184490970950469842159
149504798774472477944
147617221464859607175
149511690170196297601
149515440191710958344
147640968648033043442
147615336695526331876
149507026728728922625
147605885087855416546
149514585458749210755
149515369066995390131
149515165382436982214
147630760164006565174
149510306434372337764
149509634220697328017
149515175072200397586
147602419495756890802
149505837882118510097
149505132888594056516
147634960298097511894
149505754593894599665
147603073636183836339
149505337329364500693
147580740390356517038
149516831829922415796
149515905903500460626
147580710291224657977
149506470857034694887
149505809844128972838
147630259404782703462
149507053529215274200
147580742589380821067
147601990548774195939
149509671397939481873
149513612459909845170
149507208423361482359
147599369999984628900
149516918072664394484
147580714723636150300
149510895772701300279
149504045196683772068
149508650845178169265
149514292164015685827
149506593040439971953
329687251049256807423
149506499856618756226
147580729910633693963
149516771081719906371
147643284150797474275
149514630607440184198
147614119948501129937
149514103254184106568
149516622510201248484
396927323500500563071
147633878378891706548
149515444727526195427
149513695679119102115
149504619966396629313
149507087201955484902
149509457680463829732
147633194757222569508
149505977519891285378
147616465687934926915
147580740115484378346
147580730838345056302
147639253684956168290
149512810847423955096
149504154666903540179
149508984821393129672
147591351742713825075
149514606693367939941
149515628757847642290
147580728776768619308
149503978538791865665
149510340862833852551
149515040381937915473
149512430759876500166
149504822070624649363
149509009148210579073
197868465093829186319
149516618936779538552
149504111030215117173
147590363625806102743
147580745509961204060
149510833925072095218
147633290964659866104
149515314572478122290
149511187211900420167
147641058876707045464
147631211582037427028
149514100024739369667
392645642826235895327
149506103963490453156
149504177619305758802
149514859649462441265
149503862334411511875
149514707298733266995
149505371689187281425
149515006021942118535
149505301938769500865
147580714414400602235
147629361309940187255
147592972491902419703
147580737091815866812
149510987582200092050
149516360826428589828
147629351139777452772
149512370767448250866
194948060945999935199
147625933788912550290
149514364731789941447
149516645531617067207
149509109341362852338
149507540200729870513
439744456460315057039
147580724928468486094
147625892213704623637
149510068458829126358
149513421626133186995
147585257390277132326
147580737538511339566
147576204423850360845
