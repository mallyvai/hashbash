"""
Run with form
simulate.py codefile configfile

configfile has the form:
	max_allowed_cycles: 
	
machine code files have one instruction per line. "comment" lines
are of the form
# mycomment
these are intended to be used for comments, but also for possible
chromosomal division of sorts.

The simulator reads in files and returns the 'hashes' generated by them.

"""
import sys
import bit_params as c

dbg_brk = lambda : None

if c.ENABLE_DEBUG:
	try:
		import IPython
		dbg_brk = IPython.Debugger.Tracer()
	except ValueError: 
		None


def restricted_left_shift(num, shift_amount, num_bits):
	word_mask = (2**num_bits) - 1
	return (num << shift_amount) & word_mask;
def restricted_circ_left_shift(num, shift_amount, num_bits):
	shift_amount %= num_bits
	return restricted_left_shift(num, shift_amount, num_bits) | (num >> (num_bits - shift_amount))
def restricted_circ_right_shift(num, shift_amount, num_bits):
	return restricted_circ_left_shift(num, num_bits-shift_amount, num_bits)

get_field = lambda instr, mask, shift: (instr & mask) >> shift 

def get_msd(field, mask):
	if field & mask == 0:
		return 0
	return 1

class Halted(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)

class BadOpcode(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)

"""
Converts an ASCII string to a big integer
"""
def string_to_integer(string):
	i = 0
	ret_int = 0
	while i < len(string):
		ret_int <<= 8
		ret_int += ord(string[i])
		i += 1
		
	return ret_int

def reverse_bits(num):
	ret_int = 0
	
	while num > 0:
		ret_int <<= 1
		ret_int += (num & 1)
		num >>= 1
	return ret_int

def test_reverse_bits():
	print "13 should be 11", 13, reverse_bits(13)
	print "0 should be 0:", 0, reverse_bits(0)	
	print "7 should be 7:", 7, reverse_bits(7)

import random
def test_program_output():
	memory = [0 for i in xrange(c.NUM_WORDS)]
	
	running = 0
	
	for i in xrange(c.WI_OUTPUT_START, c.WI_OUTPUT_END+1):
		num = random.getrandbits(c.NUM_BITS)
		running <<= c.NUM_BITS
		running += num
		memory[i] = num
		
	program = Program(memory, "blah")
	output = program.get_output()
	print "it says", running
	print "num is ", output

class st_input:
	"""
	input_string gets converted into an integer
	size is the net size of input in *bits*; implicitly these means that any
	function that uses this thing can only handle about 2^68 in its input size
	"""
	def __init__(self, input_string):
		self.input_string = input_string
		self.input_bits = reverse_bits(string_to_integer(input_string))
		self.bitsize = len(input_string) * 8
		self.cursor = 0
		
	
	def next(self, num_bits):
		mask = 2**num_bits - 1
		mask <<= self.cursor
		self.cursor += num_bits
		self.cursor %= self.bitsize
		return reverse_bits(mask & self.input_bits)
	
	def prev(self, num_bits):
		mask = 2**num_bits - 1
		self.cursor -= num_bits
		self.cursor %= self.bitsize
		mask <<= self.cursor
		return reverse_bits(mask & self.input_bits)

class Program:
	"""
	A class for representing and simulating a program.
	Has no notion of "maximum cycles"; just blindly steps through
	one cycle at a time.
	"""

	#If we're at the end and we go "forward" again, just repeat the block.
	#Same with if we're at the beginning and go "backward" again.

	def _iter_input(self, forward):
		bits = None
		if forward:
			bits = reverse_bits(self.st_in.next(c.BLOCK_SIZE * c.NUM_INPUT_BLOCKS))
		else:
			bits = reverse_bits(self.st_in.prev(c.BLOCK_SIZE * c.NUM_INPUT_BLOCKS))
		
		i = c.WI_INPUT_START
		while i <= c.WI_INPUT_END:
			self.memory[i] = reverse_bits(bits & c.BLOCK_MASK)
			bits >>= c.BLOCK_SIZE
			i += 1
			
		self.memory[c.WI_TOTAL_INPUT_SIZE] = self.st_in.bitsize
		self.memory[c.WI_BLOCK_SIZE] = c.BLOCK_SIZE #Index of the word the block size for the input is going to be dumped into every time iterinput is called
		self.memory[c.WI_NUM_INPUT_BLOCKS] = c.NUM_INPUT_BLOCKS #Index for number of blocks a call to iterinput will create
		
	def __init__(self, memory, inputstring):
		self.memory = memory
				
		self.st_in = st_input(inputstring)
		self.is_halted = False
	
		self.memory[c.WI_PROGRAM_COUNTER] = c.WI_PROGRAM_START
	
	def get_output(self):
		
		i = 0
		ret_num = 0
		while i < (c.WI_OUTPUT_END - c.WI_OUTPUT_START + 1):
			ret_num <<= c.BLOCK_SIZE
			ret_num += self.memory[i + c.WI_OUTPUT_START]
			i += 1
		return ret_num	
	
	def next_step(self):
		if self.is_halted:
			raise Halted("Program halted")
		
			
		m = self.memory
		
		pc = m[c.WI_PROGRAM_COUNTER]
		pc = abs(pc)
		
		if pc > c.NUM_WORDS: instr = c.ops["halt"]

		
		m[c.WI_PROGRAM_COUNTER] += 1 #pc++
		instr = m[pc]
		
			
		def get_xor(field):
			ret = 1 & field
			while field != 0:
				field >>= 1
				ret ^= (1 & field)
			return ret
		
		f_op = get_field(instr, c.M_OPCODE, c.S_OPCODE)
		f_x = get_field(instr, c.M_X, c.S_X)
		f_y = get_field(instr, c.M_Y, c.S_Y)
		f_z = get_field(instr, c.M_Z, c.S_Z)
		f_dest = get_field(instr, c.M_DEST, c.S_DEST)

		msd_x = get_msd(f_x, c.B_X)
		msd_y = get_msd(f_y, c.B_Y)
		msd_z = get_msd(f_z, c.B_Z)
		msd_dest = get_msd(f_dest, c.B_DEST)
		
		xor_x = get_xor(f_x)
		xor_y = get_xor(f_y)
		xor_z = get_xor(f_z)
		xor_dest = get_xor(f_dest)
		
		x = None
		y = None
		z = None
		dest = None
		
		if msd_x == c.IMM:
			x = f_x & c.M_FVAL
			if c.ENABLE_DEBUG: print "x is imm"
		else: 
			x = m[f_x]
			if c.ENABLE_DEBUG: print "pulling x from mem", f_x
		
		if msd_y == c.IMM:
			y = f_y & c.M_FVAL
			if c.ENABLE_DEBUG: print "y is imm"
		else: 
			y = m[f_y]
			if c.ENABLE_DEBUG: print "pulling y from mem", f_y
		
		if msd_z == c.IMM:
			z = f_z & c.M_FVAL
			if c.ENABLE_DEBUG: print "y is imm"
		
		else:
			z = m[f_z]
			if c.ENABLE_DEBUG: print "pulling z from mem", f_z
		
		if msd_dest == c.IMM:
			dest = f_dest & c.M_FVAL
			if c.ENABLE_DEBUG: print "dest is imm"
		else: 
			dest = m[f_dest] & c.M_FVAL
			if c.ENABLE_DEBUG: print "pulling dest from mem"
		
		dbg_brk()
		if c.ENABLE_DEBUG: print c.r_ops[f_op]
		
		"""Now lets go and actually do the calculations..."""
		if f_op == c.ops["and"]: m[dest] = x & y
		elif f_op == c.ops["nand"]: m[dest] = ~(x & y)
		elif f_op == c.ops["xor"]: m[dest] = x ^ y
		elif f_op == c.ops["or"]: m[dest] = x | y
		elif f_op == c.ops["not"]: m[dest] = ~x
		
		elif f_op == c.ops["mod"]: 
			if y > 0:
				m[dest] = x % y
			else:
				m[dest] = x
				
		elif f_op == c.ops["add"]: 
			if xor_z == 1: y *= -1 #sub if the relevant bit is 1
			if c.ENABLE_DEBUG: print "X+Y=", x+y
			if c.ENABLE_DEBUG: print "X", x,"","Y", y
			m[dest] = x + y
		elif f_op == c.ops["shift"]:
			y = abs(y)
			y %= sys.maxint
			
			if xor_z == 1:
				m[dest] = restricted_left_shift(x, y, c.NUM_BITS)	 #shift left
			else:  #shift right
				m[dest] = x >> y
		elif f_op == c.ops["cshift"]:
			y = abs(y)
			y %= sys.maxint
			
			if xor_z == 1:
				m[dest] = restricted_circ_left_shift(x, y, c.NUM_BITS)
			else:
				m[dest] = restricted_circ_right_shift(x, y, c.NUM_BITS)
				
		elif f_op == c.ops["addifeq"]:
			if x == y:
				m[dest] = m[dest] + z
		elif f_op == c.ops["addifneq"]:
			if x != y:
				m[dest] = m[dest] + z
		elif f_op == c.ops["addiflt"]:
			if x < y:
				m[dest] = m[dest] + z
		
		elif f_op == c.ops["setifeq"]:
			if x == y:
				m[dest] = z
		elif f_op == c.ops["setiflt"]:
			if c.ENABLE_DEBUG: print "SETIFLTING"
			if x < y:
				m[dest] = z
		
		elif f_op == c.ops["iterinput"]:
			self._iter_input(xor_x == 1)
		
		elif f_op == c.ops["halt"]:
			if c.ENABLE_DEBUG: print "GOING DOWN FOR HALT!"
			self.is_halted = True
		else:
			raise BadOpcode(f_op)

		m[dest] %= 0x100000000000000000 #Because we have 68-bit words, 2^68 is the modulus

def prettify_instr(instr):
	f_op = get_field(instr, c.M_OPCODE, c.S_OPCODE)
	f_x = get_field(instr, c.M_X, c.S_X)
	f_y = get_field(instr, c.M_Y, c.S_Y)
	f_z = get_field(instr, c.M_Z, c.S_Z)
	f_dest = get_field(instr, c.M_DEST, c.S_DEST)
	
	d = c.Denary2Binary
	
	return (d(f_dest), d(f_z), d(f_y), d(f_x), d(f_op), str(instr))


class MemTrack:
	def __init__(self, mem):
		self.states = []
		self.states.append(mem[:])
	def next_state(self, mem):
		self.states.append(mem[:])
	def output(self):
		for i, v in enumerate(self.states):
			print "-----State " + str(i) + "-----"
			for j, w in enumerate(v):
				if w != 0:
					print j, ' '.join(prettify_instr(w))

"""
Opportunity for mad-scientist experiment: let full state of program be
transferred on reset - self-extending polymorphic code? Not impossible.
Merely very unlikely.
"""
def initialize_memory(filename):
	memory = [0 for i in xrange(0, c.WI_PROGRAM_START)]

	
	fh = open(filename, 'r')
	lines = fh.readlines()
	fh.close()
	
	
	memory.extend([int(line) for line in lines if line[0] != '#' and not line.isspace()])
	while len(memory) < c.NUM_LINES:
		memory.append(0)

	"""
	Experimental: Initialize all temporary registers to random values.
	"""
	
	memory[c.WI_TEMP_REGS_START: c.WI_TEMP_REGS_END+1] = [random.getrandbits(c.NUM_BITS) for i in xrange(c.WI_TEMP_REGS_END + 1 - c.WI_TEMP_REGS_START)]
			
	if c.ENABLE_DEBUG: print "beginning simulation"
	
	return memory

def simulate(memory, input_string):
	p = Program(memory, input_string)
	if c.ENABLE_DEBUG: tracker = MemTrack([0])
	
	i = 0
	while i < c.MAX_CYCLES and not p.is_halted:
		#if i % 500 == 0:
		#	print "Cycle", i
		if c.ENABLE_DEBUG: tracker.next_state(p.memory)
		p.next_step()
		
		if c.ENABLE_DEBUG: print "Cycle", i
		i += 1
		
	out = p.get_output()
	if c.ENABLE_DEBUG: tracker.output()
	
	return out

def main(filename, input_string):
	memory = initialize_memory(filename)
	output = simulate(memory, input_string)
	return output

if __name__ == "__main__":
	input_string = raw_input("String you want to hash:\n")
	output = main(sys.argv[1], input_string)
	print output