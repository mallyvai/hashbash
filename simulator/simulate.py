"""
Run with form
simulate.py codefile configfile

configfile has the form:
	max_allowed_cycles: 
	
machine code files have one instruction per line. "comment" lines
are of the form
# mycomment
these are intended to be used for comments, but also for possible
chromosomal division of sorts.

The simulator reads in files and returns the 'hashes' generated by them.

"""

import sys
import os
import math

NUM_BITS = 68
NUM_LINES =  65536
MAX_WORD_SIZE = (2**NUM_BITS) - 1


"""Shifts to get fields"""
S_OPCODE = 0
S_X = 4
S_Y = 20
S_Z = 36
S_DEST = 52

"""Masks to get fields"""
M_OPCODE = 15
M_X = 65535 << 4
M_Y = M_X << 16
M_Z = M_Y << 16
M_DEST = M_Z << 16

"""MSDigit mask for fields"""
B_OPCODE = 8
B_X = 32768
B_Y = 32768
B_Z = 32768
B_DEST = 32768

"""Opcode values with shorthand"""
ops = opcodes = {
		"and": 0,
	  	"nand": 1,
		"xor": 2,
		"or": 3,
		"not": 4,
		"mod": 5,
		"add": 6,
		"cshift": 7,
		"shift": 8,
		"addifeq": 9,
		"addifneq": 10,
		"addiflt": 11,
		"": 12,
		"": 13,
		"": 14,
		"iterinput": 15,
		"halt": 16 }

IMM = 1
MAX_CYCLES = 50000


BLOCK_SIZE = NUM_BITS
BLOCK_MASK = 2**BLOCK_SIZE - 1
NUM_INPUT_BLOCKS = 2 * 3 *  BLOCK_SIZE # Number of blocks a call to iterinput will start.
NUM_OUTPUT_BLOCKS = 2 
#WI is Word Index; aka the location in memory
WI_PROGRAM_COUNTER = 0 #Index in which the program counter is stored

WI_TOTAL_INPUT_SIZE = 12 #The index of the word the total size of the input is going to be dumped into every time every time iterinput is called
WI_BLOCK_SIZE = WI_TOTAL_INPUT_SIZE + 2 #Index of the word the block size for the input is going to be dumped into every time iterinput is called
WI_NUM_BLOCKS = WI_BLOCK_SIZE + 2 #Index for number of blocks a call to iterinput will create
WI_INPUT_START = WI_NUM_BLOCKS + 2 #Index of the word the input's going to start in
WI_INPUT_END = WI_INPUT_START + NUM_INPUT_BLOCKS - 1
WI_OUTPUT_START = WI_INPUT_END + 1
WI_OUTPUT_END = WI_OUTPUT_START + NUM_OUTPUT_BLOCKS - 1
WI_PROGRAM_START = WI_OUTPUT_END + 1 #Index of the word the program itself is going to start in.

def restricted_left_shift(num, shift_amount, num_bits):
	word_mask = (2**num_bits) - 1
	return (num << shift_amount) & word_mask;
def restricted_circ_left_shift(num, shift_amount, num_bits):
	return restricted_left_shift(num, shift_amount, num_bits) | (num >> (num_bits - shift_amount))
def restricted_circ_right_shift(num, shift_amount, num_bits):
	return restricted_circ_left_shift(num, num_bits-shift_amount, num_bits)

"""
Converts an ASCII string to a big integer
"""
def string_to_integer(string):
	i = 0
	ret_int = 0
	while i < len(string):
		ret_int <<= 8
		ret_int += ord(string[i])
		
	return ret_int

def reverse_bits(num):
	ret_int = 0
	
	while num > 0:
		ret_int <<= 1
		ret_int += (num & 1)
		num >>= 1
	return ret_int

def test_reverse_bits():
	print "13 should be 11", 13, reverse_bits(13)
	print "0 should be 0:", 0, reverse_bits(0)	
	print "7 should be 7:", 7, reverse_bits(7)



class st_input:
	"""
	input_string gets converted into an integer
	size is the net size of input in *bits*; implicitly these means that any
	function that uses this thing can only handle about 2^68 in its input size
	"""
	def __init__(self, input_string):
		self.input_string = input_string
		self.input_bits = reverse_bits(string_to_integer(input_string))
		self.bitsize = len(input_string) * 8
		self.cursor_small = 0  #represents the index of the small *from the next block*
		self.cursor_big = 0 #represents the index of the big
		self.cursor = 0
		
		num_bits = 8
	
	def next(num_bits):
		mask = BLOCK_MASK
		mask <<= self.cursor
		self.cursor += num_bits
		self.cursor %= self.bitsize
		return reverse_bits(mask & self.input_bits)
	
	def prev(num_bits):
		mask = BLOCK_MASK
		mask <<= self.cursor
		self.cursor -= num_bits
		self.cursor %= self.bitsize
		return reverse_bits(mask & self.input_bits)
		
	#def prev(num_bits):
		

class Program:
	"""
	A class for representing and simulating a program.
	Has no notion of "maximum cycles"; just blindly steps through
	one cycle at a time.
	"""

	#If we're at the end and we go "forward" again, just repeat the block.
	#Same with if we're at the beginning and go "backward" again.

	def _iter_input(self, forward):
		bits = None
		if forward:
			bits = reverse_bits(self.st_in.next(BLOCK_SIZE * NUM_INPUT_BLOCKS))
		else:
			bits = reverse_bits(self.st_in.prev(BLOCK_SIZE * NUM_INPUT_BLOCKS))
		
		i = WI_INPUT_START
		while i <= WI_INPUT_END:
			self.memory[i] = reverse_bits(bits & BLOCK_MASK)
			bits >>= BLOCK_SIZE
			i += 1
	
	def __init__(self, inputstring):
		self.memory = [0 for i in xrange(0, WI_PROGRAM_START)]

		fh = open(sys.argv[1], 'r')
		lines = fh.readlines()
		fh.close()

		self.memory.append([int(line) for line in lines if line[0] != '#'])
		while len(self.memory) < NUM_LINES:
			self.memory.append(0)
		
		self.st_in = st_input(inputstring)
		self.halted = False
	

		self.memory[WI_TOTAL_INPUT_SIZE] = self.st_in.size
		self.memory[WI_BLOCK_SIZE] = BLOCK_SIZE #Index of the word the block size for the input is going to be dumped into every time iterinput is called
		self.memory[WI_NUM_BLOCKS] = NUM_BLOCKS #Index for number of blocks a call to iterinput will create
		self.memory[WI_PROGRAM_COUNTER] = WI_PROGRAM_START
	
	def next_step(self):
		m = self.memory
		pc = m[WI_PROGRAM_COUNTER]
		m[WI_PROGRAM_COUNTER] += 1 #pc++
		instr = m[pc]
		
		if self.halted:
			raise "halted"
		
		get_field = lambda instr, mask, shift: (instr & mask) >> shift 
		def get_msd(field, mask):
			if field & mask == 0:
				return 0
			return 1
		
		f_op = get_field(instr, M_OPCODE, S_OPCODE)
		f_x = get_field(instr, M_X, S_X)
		f_y = get_field(instr, M_Y, S_Y)
		f_z = get_field(instr, M_Z, S_Z)
		f_dest = get_field(instr, M_DEST, S_DEST)
		
		msd_x = get_msd(f_x, B_X)
		msd_y = get_msd(f_y, B_Y)
		msd_z = get_msd(f_z, B_Z)
		msd_dest = get_msd(f_dest, B_DEST)
		
		x = None
		y = None
		z = None
		dest = None
		
		if msd_x is IMM: x = f_x
		else: x = m[f_x]
		
		if msd_y is IMM: y = f_y
		else: y = m[f_y]
		
		if msd_z is IMM: z = f_z
		else: z = m[f_z]
		
		if msd_dest is IMM: dest = f_dest
		else: dest = m[f_dest]
		
		"""Now lets go and actually do the calculations..."""
		if f_op is ops["and"]: m[dest] = x & y
		elif f_op is ops["nand"]: m[dest] = ~(x & y)
		elif f_op is ops["xor"]: m[dest] = x ^ y
		elif f_op is ops["or"]: m[dest] = x | y
		elif f_op is ops["not"]: m[dest] = ~x
		
		elif f_op is ops["mod"]: m[dest] = x % y
		elif f_op is ops["add"]: 
			if msd_z == 1: y *= -1 #sub if the relevant bit is 1
			m[dest] = (x + y) % 0x100000000000000000 #Because we have 68-bit words, 2^68 is the modulus
		elif f_op is ops["shift"]:
			if msd_z is 1:
				m[dest] = restricted_left_shift(x, y, num_bits)	 #shift left
			else:  #shift right
				m[dest] = x >> y
		elif f_op is ops["cshift"]:
			if msd_z is 1:
				m[dest] = restricted_circ_left_shift(x, y, num_bits)
			else:
				m[dest] = restricted_circ_right_shift(x, y, num_bits)
		elif f_op is ops["addifeq"]:
			if x == y:
				m[dest] = (m[dest] + z) % MAX_WORD_SIZE + 1
		elif f_op is ops["addifneq"]:
			if x != y:
				m[dest] = (m[dest] + z) % MAX_WORD_SIZE + 1
		elif f_op is ops["addiflt"]:
			if x < y:
				m[dest] = (m[dest] + z) % MAX_WORD_SIZE + 1
		
		elif f_op is ops["iterinput"]:
			self._iter_input(msd_x is 1)
		
		elif f_op is ops["halt"]:
			self.halted = True
		


def Denary2Binary(n):
	#
	'''convert denary integer n to binary string bStr'''
	#
	bStr = ''
	#
	if n < 0: raise ValueError, "must be a positive integer"
	#
	if n == 0: return '0'
	#
	while n > 0:
	#
		bStr = str(n % 2) + bStr
		#
		n = n >> 1
		#
	return bStr

