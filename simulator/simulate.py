"""
Run with form
simulate.py codefile configfile

configfile has the form:
	max_allowed_cycles: 
	
machine code files have one instruction per line. "comment" lines
are of the form
# mycomment
these are intended to be used for comments, but also for possible
chromosomal division of sorts.

The simulator reads in files and returns the 'hashes' generated by them.

"""

import sys

NUM_LINES =  65536
MAX_WORD_SIZE = 0x100000000000000000
NUM_BITS = 68

"""Shifts to get fields"""
S_OPCODE = 0
S_X = 4
S_Y = 20
S_Z = 36
S_DEST = 52

"""Masks to get fields"""
M_OPCODE = 15
M_X = 65535 << 4
M_Y = M_X << 16
M_Z = M_Y << 16
M_DEST = M_Z << 16

"""MSDigit mask for fields"""
B_OPCODE = 8
B_X = 32768
B_Y = 32768
B_Z = 32768
B_DEST = 32768

"""Opcode values with shorthand"""
ops = opcodes = {
		"and": 0,
	  	"nand": 1,
		"xor": 2,
		"or": 3,
		"not": 4,
		"mod": 5,
		"add": 6,
		"cshift": 7,
		"shift": 8,
		"addifeq": 9,
		"addifneq": 10,
		"addiflt": 11,
		"": 12,
		"": 13,
		"": 14,
		"iterinput": 15,
		"halt": 16 }

IMM = 1
MAX_CYCLES = 50000

# B and C should ALWAYS be directly above A.
WI_INPUT_START = 12 #A) The index of the starting word the input will be dumped into every time the magic function is called.
WI_TOTAL_INPUT_SIZE = 10 #B) The index of the word the total size of the input is going to be dumped into every time the magic function is called 
WI_BLOCK_SIZE = 11#C) The index of the word the input's blocksize will be dumped into every time the magic function is called
WI_PROGRAM_START = 29 #Index for which the program starts - the first value of PC
WI_PROGRAM_COUNTER = 0 #Index in which the program counter is stored

def restricted_left_shift(num, shift_amount, num_bits):
	word_mask = (2**num_bits) - 1
	return (num << shift_amount) & word_mask;

def restricted_circ_left_shift(num, shift_amount, num_bits):
	return restricted_left_shift(num, shift_amount, num_bits) | (num >> (num_bits - shift_amount))
def restricted_circ_right_shift(num, shift_amount, num_bits):
	return restricted_circ_left_shift(num, num_bits-shift_amount, num_bits)

class Program:
	"""
	A class for representing and simulating a program.
	Has no notion of "maximum cycles"; just blindly steps through	
	one or more cycles at a time.
	"""
	def __init__(self, filename):
		self.memory = [0 for i in xrange(0, WI_PROGRAM_START)]
		
		fh = open(sys.argv[1], 'r')
		lines = fh.readlines()
		fh.close()
		self.memory.append([int(line) for line in lines if line[0] != '#'])
		while len(self.memory) < NUM_LINES:
			self.memory.append(0)
		self.memory[WI_PROGRAM_COUNTER] = WI_PROGRAM_START
		
		self.num_cycles	= 0
			
	def next_step(self, num_steps):
		m = self.memory
		pc = m[WI_PROGRAM_COUNTER]
		instr = m[pc]
		
		get_field = lambda instr, mask, shift: (instr & mask) >> shift 
		def get_msd(field, mask):
			if field & mask == 0:
				return 0
			return 1
		
		f_op = get_field(instr, M_OPCODE, S_OPCODE)
		f_x = get_field(instr, M_X, S_X)
		f_y = get_field(instr, M_Y, S_Y)
		f_z = get_field(instr, M_Z, S_Z)
		f_dest = get_field(instr, M_DEST, S_DEST)
		
		msd_x = get_msd(f_x, B_X)
		msd_y = get_msd(f_y, B_Y)
		msd_z = get_msd(f_z, B_Z)
		msd_dest = get_msd(f_dest, B_DEST)
		
		x = None
		y = None
		z = None
		dest = None
		
		if msd_x is IMM: x = f_x
		else: x = m[f_x]
		
		if msd_y is IMM: y = f_y
		else: y = m[f_y]
		
		if msd_z is IMM: z = f_z
		else: z = m[f_z]
		
		if msd_dest is IMM: dest = f_dest
		else: dest = m[f_dest]
		
		"""Now lets go and actually do the calculations..."""
		if f_op is ops["and"]: m[dest] = x & y
		elif f_op is ops["nand"]: m[dest] = ~(x & y)
		elif f_op is ops["xor"]: m[dest] = x ^ y
		elif f_op is ops["or"]: m[dest] = x | y
		elif f_op is ops["not"]: m[dest] = ~x
		
		elif f_op is ops["mod"]: m[dest] = x % y
		elif f_op is ops["add"]: 
			if msd_z == 1: y *= -1 #sub if the relevant bit is 1
			m[dest] = (x + y) % 0x100000000000000000 #Because we have 68-bit words, 2^68 is the modulus
		elif f_op is ops["cshift"]:
			if msd_z is 1:
				None	 #shift left
			else: None #shift right

def Denary2Binary(n):
	#
	'''convert denary integer n to binary string bStr'''
	#
	bStr = ''
	#
	if n < 0: raise ValueError, "must be a positive integer"
	#
	if n == 0: return '0'
	#
	while n > 0:
	#
		bStr = str(n % 2) + bStr
		#
		n = n >> 1
		#
	return bStr